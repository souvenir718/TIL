# 코딩테스트 출제 경향 분석 및 파이썬 문법 부수기



## 요구사항에 따라 알고리즘 설계하기

- 문제에서 가장 먼저 확인해야 하는 내용은 시간제한(수행시간 요구사항)이다.
- 시간제한이 1초인 문제를 만났을 때, 기준은 아래와 같다.
  - N의 범위가 500인 경우 : 시간 복잡도가 O(N^3)인 알고리즘을 설계
  - N의 범위가 2,000인 경우 : 시간 복잡도가 O(N^2)인 알고리즘을 설계
  - N의 범위가 100,00인 경우 : 시간 복잡도가 O(NlogN)인 알고리즘을 설계
  - N의 범위가 10,000,000인 경우 : 시간 복잡도가 O(N)인 알고리즘을 설계



## 수행 시간 측정 소스코드 예제

```python
import time
start_time = time.time() # 측정 시작

# 코드

end_time = time.time() # 측정 종료
print("time: ", end_time - start_time)
```



## 자료형

### 지수표현방식

- `e`나 `E`를 이용한 지수표현 방식을 이용할 수 있다.
  - e나 E 다음에 오는 수는 10의 지수부를 의미한다.
  - 1e9를 입력하면 10의 9제곱이 된다.
- 지수 표현 방식은 임의의 큰 수를 표현하기 위해 자주 사용한다.
- 최단 경로 알고리즘에서는 도달할 수 없는 노드에 대하여 최단 거리를 무한(INF)로 설정하낟.

```python
a = 1e9 #1000000000.0
a = int(a) # 1000000000
a = 75.25e1 # 752.5
a = 3954e-3 # 3.954
```



### 실수형

- 개발 과정에서 실수 값을 제대로 비교하지 못해 원하는 결과를 얻지 못할 수 있다.

```python
a = 0.3 + 0.6
print(a) # 0.89999999999999
```

- 이럴땐 `round()` 함수를 이용할 수 있다.

- 예를 들어 123.456를 소수 셋째 자리에서 반올림하면 round(123.456, 2)라고 작성한다.
  - 결과는 123.46이 된다.



### 수 자료형의 연산

- 나누기 연산자(/)를 사용하면 실수형으로 반환한다.
- 몫을 얻기위해서는 몫 연산자(//)를 사용한다.
- 거듭 제곱 연산자는 **이다.



### 리스트 자료형

- 여러개의 데이터를 연속적으로 담아 처리하기 위해 사용하는 자료형
  
- 배열의 기능, 연결 리스트와 유사한 기능 지원
  
- 인덱싱

  ```python
  a = [1, 2, 3, 4, 5]
  
  print(a[3]) # 4
  print(a[-1]) # 5 거꾸로 인덱싱 가능
  ```

- 슬라이싱 : 연속적인 위치를 갖는 원소들을 가져와야 할때 이용한다.

  - 대괄호 안에 콜론을 넣어서 시작 인덱스와 끝 인덱스를 설정한다.
  - 끝 인덱스는 실제 인덱스보다 1을 크게 설정한다.

  ```python
  a = [1, 2, 3, 4, 5]
  
  print(a[1:4]) # [2, 3, 4] 인덱스 1부터 3까지의 값
  ```

- 리스트 컴프리헨션

  - 대괄호 안에 조건문과 반복문을 적용하여 리스트를 초기화 할 수 있다.

  ```python
  array = [i for i in range(10)] # 0부터 9까지의 수를 포함하는 리스트
  
  array = [i for i in range(20) if i%2 == i] # 0부터 19까지의 수 중에서 홀수
  
  array = [i*i for i in range(1, 10)] # 1부터 9까지의 수 제곱 값
  ```

  - 2차원 리스트를 초기화할때 효과적으로 사용될 수 있다.
  
  - **N x M** 크기의 2차원 리스트를 한번에 초기화해야 할 때 매우 유용하다.
  
    - ex) array = [[0] * m for _ in range(n)]
  
    - 파이썬에서는 반복을 수행하되 반복을 위한 변수의 값을 무시하고자 할 때 언더바(_)를 자주 사용한다.

### 리스트 관련 메서드

- append() : 리스트에 원소를 하나 삽입할 때 사용한다
  - 사용법 : 변수명.append()
  - 시간 복잡도 : O(1)
- sort() : 기본 정렬 기능으로 오름차순으로 정렬한다
  - 사용법 : 변수명.sort())
  - 시간 복잡도 : O(NlogN)
  - 변수명.sort(reverse=True) : 내림차순으로 정렬
- reverse() : 리스트의 원소 순서를 모두 뒤집어 놓는다.
  - 사용법 : 변수명.reverse()
  - 시간 복잡도 : O(N)
- insert() : 특정한 인덱스 위치에 원소를 삽입할 때 사용한다.
  - 사용법 : 변수명.insert(t삽입할 위치 인덱스, 삽입할 값)
  - 시간 복잡도 : O(N)
- count() : 리스트에 특정한 값을 가지는 데이터의 개수를 셀 때 사용한다.
  - 사용법 : 변수명.count(특정 값)
  - 시간 복잡도 : O(N)
- remove() : 특정한 값을 갖는 원소를 제거하는데, 값을 가진 원소가 여러 개면 **하나만 제거**한다.
  - 사용법 : 변수명.remove(특정값)
  - 시간 복잡도 : O(N)

- 특정 값을 가지는 원소를 모두 제거하는 방법

```python
a = [1, 2, 3, 4, 5, 5, 5];
remove_set = {3, 5} # 집합 자료형

result = [i for i in a if i not in remove_set]
print(result) # [1, 2, 4]
```



### 문자열 연산

- 인덱싱과 슬라이싱이 가능하다.
- 특정 인덱스의 값을 변경하는건 불가능하다.(Immutable)

```python
a = "Hello"
b = "World"
print(a+ " " +b) # Hello World
print(a*3) # HelloHelloHello
print(a[2:4]) # ll
```



### 튜플 자료형

- 튜플은 한번 선언된 값을 변경할 수 없다.s
- 리스트는 대괄호를 사용하지만, 튜플은 소괄호를 이용한다.
- 리스트에 비해 상대적으로 공간 효율적이다.

```python
a = (1, 2, 3, 4, 5, 6, 7, 8, 9)

print(a[3]) # 4
print(a[1:4]) #(2, 3, 4)
```

#### 튜플을 사용하면 좋은 경우

- 서로 다른 성질의 데이터를 묶어서 관리해야 할 때
  - 최단경로 알고리즘에서는 (비용, 노드번호)의 형태로 튜플 자료형을 자주 사용한다.
- 데이터의 나열을 해싱의 키 값으로 사용해야 할 때
  - 튜플은 변경이 불가능하므로 리스트와 다르게 키 값으로 사용될 수 있다.
- 리스트보다 메모리를 효율적으로 사용해야 할 때



### 사전 자료형

- 키와 값의 쌍을 데이터로 가지는 자료형이다.
- 원하는 **변경불가능한 자료형**을 키로 사용할 수 있다.
- 해시 테이블을 이용하므로 테이터의 조회 및 수정에 있어서 O(1)의 시간에 처리할 수 있다.

```python
data = dict()
data['사과'] = 'Apple'
data['바나나'] = 'Banana'
data['코코넛'] = 'Coconut'
print(data) # {'사과': 'Apple', '바나나':'Banana', '코코넛':Coconut}

if '사과' in data: # 키 체크
    print('True')

key_list = data.keys() # 키 데이터만 담은 리스트
value_list = data.values() # 값 데이터만 담은 리스트
for key in key_list:
    print(data[key])
```

- 키와 값을 별도로 뽑아내기 위한 메서드를 지원한다.
  - 키 데이터만 뽑아서 리스트로 이용할 때는 `keys()` 함수를 이용한다.
  - 값 데이터만 뽑아서 리스트로 이용할 때는 `values()` 함수를 이용한다.



### 집합 자료형

- 특징
  - 중복을 허용하지 않는다.
  - 순서가 없다.
- 리스트 혹은 문자열을 이용해서 초기화할 수 있다.
  - `set()` 함수를 이용한다.
- 중괄호 안에 각 원소를 콤마를 기준으로 구분하여 삽입함으로써 초기화할 수 있다.
- 데이터의 조회 및 수정에 있어서 O(1)의 시간에 처리할 수 있다.

```python
data = set([1, 1, 2, 3, 4, 4, 5])
print(data) # {1, 2, 3, 4, 5}

data = {1, 1, 2, 3, 4, 4, 5}
print(data) # {1, 2, 3, 4, 5}
```

- 집합 연산
  - 합집합 : 집합 A에 속하거나 B에 속하는 원소로 이루어진 집합
  - 교집합 : 양쪽에 속하는 집합
  - 차집합 : 집합 A의 원소 중에서 B에 속하지 않는 원소들로 이루어진 집합

```python
a = set([1, 2, 3, 4, 5])
b = set([3, 4, 5, 6, 7])

print(a|b) #합집합
print(a&b) #교집합
print(a-b) #차집합

data = set([1, 2, 3])
data.add(4) # 새로운 원소 추가
data.update([5, 6]) # 새로운 원소 여러개 추가 {1, 2, 3, 4, 5, 6}
data.remove(3) # 특정값 삭제
```



#### 사전 자료형과 집합 자료형 특징

- 리스트나 튜플은 순서가 있기 떄문에 인덱싱을 통해 자료형의 값을 얻을 수 있다.
- 사전 자료형과 집합 자료형은 순서가 없기 때문에 인덱싱으로 값을 얻을 수 없다.
  - 사전의 키 혹은 집합의 원소를 이용해 O(1)의 시간 복잡도로 조회한다.

### 표준 입력방법

- input() 함수는 한줄의 문자열을 입력받는 함수다.
- map() 함수는 리스트의 모든 원소에 각각 특정한 함수를 적용할 때 사용한다.
  - list(map(int, input().split()))
    - 공백을 기준으로 구분된 데이터를 입력받을 때 사용
  - a, b, c = map(int, input().split())
    - 공백을 기준으로 구분된 데이터 개수가 많지 않을때 사용