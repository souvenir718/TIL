# React



## 라이프사이클

: 리액트는 컴포넌트 기반의 View를 중심으로 한 라이브러리다. 각각의 컴포넌트에는 라이프사이클(수명주기)가 존재하고 수명은 보통 페이지에서 렌더링되기 전 준비과정에서부터 페이지에서 사라질때 끝이 난다. 컴포넌트가 처음 실행될때인 Mount, 데이터에 변화가있을때인 Update, 컴포넌트가 제거 될때인 Unmount이렇게 세개로 나눌 수 있다.

- 마운트 : DOM이 생성되고 브라우저 상에서 나타나는 것을 뜻한다.
- 업데이트 
  - props가 바뀌는 경우
  - state가 바뀌는 경우
  - 부모 컴포넌트가 리렌더링 되는 경우
  - 강제로 렌더링할 경우
- 언마운트 : DOM에서 제거되는 것을 뜻한다.



## Virtual Dom

: Virtual DOM은 애플리케이션의 UI를 구성하는 HTML 엘리먼트를 메모리 내에서 구현한 것이다.

- DOM과 유사한 객체를 메모리에 올리고 변경사항이 생기면 Virtual DOM을 수정하고 DOM과 비교하여 변경사항에 대해서만 반영하는 것을 말한다.



## JSX?

HTML처럼 보이는 코드를 작성할 수 있게 해주는 자바스크립트 문법의 확장이다. JSX는 자바스크립트 함수 호출 방식으로 컴파일되어 컴포넌트에 대한 마크업을 만들 수 있는 더 좋은 방법을 제공한다.



## Class vs Function

함수형 컴포넌트는 클래스보다 선언하기 좀 더 편하고, 함수는 한번 실행되고 나면 메모리 상에서 사라지기 때문에 메모리 자원을 덜 사용하는 것이 장점이다. 함수형 컴포넌트에서는 hook을 사용할 수 있고, return문을 사용한다.  



## Hook

: 함수형 컴포넌트에서도 클래스형 컴포넌트의 기능을 사용할 수 있게 하는 기능으로 컴포넌트의 상태값을 관리하거나 생명 주기 메소드를 이용할 수 있다.



## Key

: 컴포넌트 배열을 렌더링했을 때, 어떤 원소에 변동이 있어는지 알아내기위해 사용한다. `Key`가 없을 때는 가상 DOM을 비교한느 과정에서 리스트를 순차적으로 비교하면서 변화를 감지해야 하므로 `Key`가 있으면 어디서 변화가 일어났는지 더욱 빠르게 확인할 수 있다.



## useEffect

: 컴포넌트가 렌더링될 때마다 특정 작업을 실행할 수 있도록 하는 Hook이다.

- 컴포넌트가 마운트되거나 언마운트 혹은 업데이트 됐을때, 특정 작업을 처리할 수 있다.
- 첫번째 인수로 실행할 콜백함수를 넣고 두번째 인수로 검사하고자 하는 특정 값이나 빈 배열을 넣는다.
- 의존성 배열 검사할 때 얕은 비교를 진행한다.
  - 참조 타입인 객체, 배열, 함수의 경우 내부 프로퍼티가 동일하다하여도 리렌더링이 발생한다.
  - useCallback을 써서 참조 대상인 함수가 리렌더링이 발생할 때마다 새롭게 생성하지 않도록 한다.



## useLayoutEffect

: DOM이 변경되고나서 동기적으로 실행이 된다. 브라우저가 화면을 그리기 전에 실행이 되기 때문에 스크롤 위치를 얻어오거나 다른 DOM 엘리먼트의 스타일을 조작할 때 사용하면 효율적이다.

- DOM이 업데이트 되면 바로 동기적으로 실행이 되고 이 과정은 브라우저가 화면에 렌더링하기 이전에 수행되어 사용자는 업데이트 되기 전의 화면을 보지 않게 된다.



### useEffect vs useLayoutEffect

: 렌더링 이전에 무언가를 하고 싶다면 `useLayoutEffect`를 사용하고 렌더링 이후에 무언가를 하고 싶다면 `useEffect`를 사용

- useEffect
  - 화면에 그려진 후 비동기적으로 실행된다. 따라서 이벤트 핸들러 설정과 같이 렌더링 이후에 진행해야하는 작업에 적합하다.
  - 컴포넌트 렌더링 - 화면 업데이트 - useEffect 실행
  - 비동기적 실행
- useLayoutEffect
  - 렌더링 직후 화면이 업데이트 되기 전에 동기적으로 실행된다. 따라서 DOM 변경과 같이 렌더링이 이루어지기 전에 진행해야 하는 작업에 적합하다.
  - 컴포넌트 렌더링 - useLayoutEffect - 화면 업데이트
  - 동기적으로 실행
  - 렌더링 직후 DOM요소의 값을 읽을 때 유용





## useCallback

: 첫번째 인수로 콜백의 메모이제이션 버전을 반환한다.

- 반환된 메모이제이션 버전은 콜백의 의존성이 변경되었을 때만 변경되며, 이는 부필요한 렌더링을 방지하기 위해 참조의 동일성에 의존적인 최적화된 자식 컴포넌트에 콜백을 전달할 때 유용하다.



> **메모이제이션**
>
> : 컴퓨터 프로그램이 동일한 계산을 반복해야할 때, 이전에 계산한 값을 메모리에 저장함으로써 동일한 계산의 반복 수행을 제거하여 프로그램 실행 속도를 빠르게 하는 기술
>
> - 리액트에서 불필요한 계산, 리렌더링의 방지를 위해 사용된다.



### React.memo

`useCallback` 사용만으로 하위 컴포넌트의 리렌더링을 막을 수 없다. 하위 컴포넌트가 참조 동일성에 의존적인, 최적화된 Purecomponent이어야만 불필요한 리렌더링을 막을 수 있다.

`React.memo`는 `shouldComponentUpdate` 가 기본으로 내장된 함수형 컴포넌트로 보면 된다. 얕은 비교 연산을 통해 동일한 참조 값의 prop이 들어온다면 리렌더링을 방지시킨다.

`React.memo`는 고차 컴포넌트(HOC:Higher Order Component)로 `React.PureComponent`와 비슷하지만 class가 아니라 함수형 컴포넌트이다. 함수 컴포넌트가 동일한 props로 동일한 결과를 렌더링한다면, `React.memo`를 호출하고 결과를 메모이징하도록 래핑하여 성능향상을 확인할 수 있다. 

`React.memo`는 props 변화에만 영향을 준다. props가 갖는 복잡한 객체에 대하여 얕은 비교만을 수행하는 것이 기본 동작이며 다른 비교 동작을 원한다면 두번째 인자로 별도의 비교 함수를 제공하면 된다.

> **shouldComponentUpdate()**
>
> : props 또는 state가 새로운 값으로 갱신되어서 렌더링이 발생하기 직전에 호출된다.





## useMemo

: useCallback과 마찬가지로 메모이제이션된 값을 반환한다.

- 의존성이 변경되었을 때만 메모이제이션된 값을 다시 계산하므로 불필요한 계산을 방지한다.



## useRef

: 인수로 주어진 값을 초기값으로 하는 current 프로퍼티가 있는 개체를 반환하는 Hook

- heap영역에 저장되는 일반적인 자바스크립트 객체로 매번 렌더링할 때 동일한 객체를 제공한다.
- 어플리케이션이 종료되거나 가비지 컬렉팅될 때까지, 참조할때마다 같은 메모리 값을 가진다.



## 함수형 컴포넌트의 장점

- 클래스형 컴포넌트보다 선언이 간편하다.
- 메모리 자원을 덜 사용한다.
- 프로젝트 빌드 후 배포할 때 결과물의 파일 크기가 더 작다.



## 얕은 복사

**같은 참조 값인가? vs 같은 메모리에 할당된 값을 사용하는가?**

: 데이터가 그대로 생성되는 것이 아닌 해당 데이터의 참조 값(메모리 주소)를 전달하여 한 데이터를 공유하는 것이다.

자바스크립트의 6가지 타입 중 객체를 제외한 원시값은 참조 값이 아닌 값 자체를 새로 할당한다. 따라서 값이 변경되면 서로 다른 값을 가지게 된다.

```javascript
let value = 1;
let value2 = value;
value2 = 2;

console.log(value, value2); // 1, 2

let obj = {number : 1};
let obj2 = obj; 
obj2.number = 2;

console.log(obj); // {number : 2}
console.log(obj2); // {number : 2}
console.log(obj === obj2); // true : 같은 참조 값이므로

let arr = [1,2,3];
let arr2 = [1,2,3];

console.log(arr === arr2); // false : 다른 참조 값이므로
```



### 객체의 깊은 복사

#### Object.assign()

`Object.assign(생성할 객체, 복사할 객체)` 의 첫번째 인수로 빅 객체를 넣어주며, 두번째 인수로 할당할 객체를 넣으면 된다.

```javascript
const obj = {a : 1};
const newObj = Object.assing({}, obj);

newObj.a = 2;

console.log(obj); // {a : 1}
console.log(obj === newObj); // false
```



#### 전개 연산자

```javascript
const obj = {a : 1};
const newObj = {...obj};

newObj.a = 2;

console.log(obj); // {a : 1}
console.log(obj === newObj); // false
```

> 2가지 방법 모두 2차원 객체에서는 깊은 복사가 이뤄지지 않는다.



## 제어 컴포넌트 vs 비제어 컴포넌트

### 제어 컴포넌트

: 사용자의 입력을 기반으로 자신의 state를 관리하고 업데이트한다.

- 제어 컴포넌트의 값은 **항상 최신값**을 유지한다. 새로운 입력 값이 생길때마다 상태를 새롭게 갱신한다.
- 데이터와 UI에서 입력한 값이 항상 동기화됨을 알 수 있다.
- 사용
  - 유효성 검사
  - 유효한 데이터가 없는 경우 전송 버튼의 상태를 disabled로 표시
  - 신용카드와 같은 특정 입력 방식 적용
- 문제점
  - 사용자가 입력하는 모든 데이터가 동기화되어 불필요한 렌더링, api요청 등으로 자원 낭비가 될 수 있다.



### 비제어 컴포넌트

: `setState()`를 사용하지 않고 `ref`를 이용해서 값을 얻는다. 값이 실시간으로 동기화 되지 않으며, 직접 트리거하기 전까지는 리렌더링을 발생시키지도 않고 값을 동기화 시키지도 않는다.



### 정리

- 즉각적으로 값에 대한 피드백이 필요할 때 ? **제어 컴포넌트**
- 즉각적인 피드백이 불필요하고 제출시에만 값이 필요할 때 ? **비제어 컴포넌트**
