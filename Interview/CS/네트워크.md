# 네트워크



### HTTP 메소드

- **POST** : 서버나 특정 리소스에 엔티티를 제출할 때 사용한다. Create, Update, Delete 등을 할 때 사용하기도 한다. (Create)
- **GET** : 특정 리소스의 참조를 요청한다. (Read)
- **PUT** : 해당 리소스를 수정할 때 사용한다. 전체 리소스를 업데이트 하는데 사용한다.(Update)
- **DELETE** : 삭제할 때 사용한다. (Delete)
- **PATCH** : 리소스의 부분적으로 수정할 때 사용한다.



### HTTP 1.1 vs HTTP 2.0

**HTTP(HyperText Transfer Protocol)**

: WWW에서 하이퍼텍스트 문서를 교환하기 위해 사용되는 통신규약

**HTTP/1.1**

연결당 하나의 요청을 처리하도록 설계되어 있어서 동시 전송이 불가능하며, 요청과 응답이 순차적으로 이루어진다. 그로인해 HTTP 문서안에 포함된 다수의 리소스를 처리하려면 개수에 비례해서 대기시간이 길어진다.

- 단점
  - HOL(Head Of Line) Blocking : 특정 읍답의 지연
  - RTT(Round Trip Time) 증가
  - 무거운 헤더 구조(특히 Cookie)



**HTTP/2.0**

- 장점
  - Multiplexed Streams
    - 한 커넥션으로 동시에 여러 개의 메시지를 주고 받을 수 있으며, 응답은 순서에 상관없이 stream으로 주고 받는다.
  - Stream Prioritization
    - 리소스간 우선순위를 설정하여 렌더링이 늦어지는 문제 해결
  - Server Push
    - 서버는 클라이언트의 요청에 대해 요청하지도 않은 리소스를 보낼 수 있다.
    - 클라이언트의 요청을 최소화해서 성능 향상을 이끌어 낸다.
    - PUSH_PROMISE라고 부르며 PUSH_PROMISE를 통해서 서버가 전송한 리소스에 대해선 클라이언트는 요청을 하지 않는다.



### HTTP request and response

1. 웹페이지 요청을 위해 Get request를 서버에 보낸다. 이때 쿠키에 해당 웹페이지에 대한 정보가 담겨있다면 헤더에 포함되어 함께 보내진다.
2. 서버에 WAS(Web Application Server)가 있다면 백엔드 엔지니어가 설계한대로 request에 대한 핸들링을 해준다. 그리고 response를 JSON, XML 등 포맷에 맞춰 만들어준다.
3. 서버는 status code와 함께 response를 보낸다.



###  HTTP 프로토콜 특징

- 비연결 지향(connectionless) : 클라이언트가 request를 서버에 보내고, 서버가 클라이언트 요청에 맞는 response를 보내면 바로 연결을 끊는다.
- 상태정보 유지 안함(stateless) : 연결을 끊는 순간 클라이언트와 서버의 통신은 끝나며 상태 정보를 유지하지 않는다.



### HTTP와 HTTPS(HTTP + Secure Socket)차이

기본 골격이나 사용목적 등은 거의 동일하지만, 데이터를 주고 받는 과정에 '보안'요소가 추가된다는 것이 가장 큰 차이점이다. HTTPS를 사용하면 서버와 클라이언트 사이의 모든 통신 내용이 암호화 된다. HTTPS는 웹 서버에 접속하는 사용자마다 다른 암호를 제공해야 하기 때문에 쉽지 않다.

#### HTTPS 특징

보안 요소가 추가된만큼 처리속도는 느릴 수 밖에 없고 관련 웹서버의 사양도 중요하다. 가벼운 웹서핑이라면 HTTP를 사용해도 되지만 자료를 주고 받는 경우에는 개인정보 유출로 이어질 수 있다. 



### URL에 www.example.com을 쳤을 때 일어나는 일

URL(Uniform Resource Locator)은 ip주소를 대신해서 사람에게 기억하기 쉬운 문자로 만들어졌다. 도메인 이름과 ip주소를 domain name server에서 DB로 관리한다. 이러한 시스템을 Domain Name System이라고 한다. URL에 담긴 문법구조를 브라우저가 파악해서 올바른 문법구조로 되어있는지 확인한다.

#### 올바른 문법구조라면

1. 브라우저에는 최근 방문한 페이지의 DNS 기록을 일정시간 저장해놓는 캐시가 있다. DNS를 활용하기 위해 먼저 캐시를 확인한다.
2. 만약 없다면, OS에 있는 캐시를 확인한다.
3. OS에도 없다면 라우터에 있는 캐시에 확인한다.
4. 라우터에도 없다면 URL을 입력할 때 이에대한 요청은 일반적으로 Internet Service Provider라고 하는 인터넷 공급업체나 기업 네트워크 DNS 해석기로 라우팅 된다. 해당 ISP 캐시가 기록을 가지고 있는지 마지막으로 확인한다.
5. ISP는 DNS서버를 가지고 있는데 해당 URL과 맵핑되는 ip주소가 있는지 확인하고 없으면 에러, 있으면 해당 ip주소를 DNS서버로부터 가져온다.



#### TCP Connection

리소스를 요청할 서버가 어딨는지 알게 되었으니 브라우저는 서버와 TCP connection을 맺고 요청한 데이터를 받을 다리를 건설한다. 이것을 3-way-handshaking이라고 한다. 

UDP의 경우 이 과정이 없으나 http 프로토콜의 경우 TCP connection이 default이므로 데이터 이동 전에는 이 과정이 항상 선행된다고 볼 수 있다.



### 웹브라우저를 통해 서버에 이미지를 요청해서 보여주기까지의 과정

1. 웹브라우저가 이미지를 요청해야한다는 것을 인지한다.
2. 웹브라우저는 url을 통해 서버에 ip를 추출한다.
3. 이미지를 요청하기 위한 HTTP 메세지를 만든다.
4. get메서드이고 /image.png를 요청하는 메세지이다.
5. 웹브라우저는 서버와 TCP connection을 맺는다.
6. 웹브라우저는 서버에 HTTP 요청을 보낸다.
7. 서버는 메세지를 받고 무슨 내용인지 해석한다. 
8. get메서드이고 /image.png라는 파일을 요청했다는 것을 인지한다.
9. 서버는 해당 리소스가 있는지 찾고 있으면 200 상태코드와 함께 응답 메시지를 작성한다.
10. 서버는 클라이언트와 TCP connection을 맺는다.
11. 클라이언트에 HTTP 응답을 보낸다.
12. 커넥션이 닫히면 웹브라우저는 사용자에게 이미지를 보여준다.



### 쿠키와 세션

쿠키와 세션은 HTTP 프로토콜의 특징이자 약점을 보완하기 위해서 사용한다. HTTP 프로토콜은 Connectionless, Stateless이기 때문에 클라이언트와 서버가 통신이 끝난 후 연결이 끊기고 데이터 상태 정보를 유지하지 않는다.

하지만 로그인 후 유저 정보나 상품을 선택했을때 구매 정보가 없어지는 일이 발생하면 안되기 때문에 웹 서버가 사용자의 상태 정보를 기억하기 위해 쿠키와 세션을 사용한다.



#### 세션 특징

- 일정 시간 동안 같은 브라우저로부터 들어오는 요청을 하나의 상태로 보고 그 상태를 유지하는 기술이다.
- 웹 브라우저를 통해 서버에 접속한 이후부터 브라우저를 종료할 때까지 유지되는 상태이다.

- 클라이언트에서 관리하는 쿠키에 비해서 서버에 저장하는 세션은 보안이 좋다

- 서버 자원을 사용하기 때문에 사용자가 많을 경우 자원을 많이 소모할 수 있다.

- 세션은 브라우저가 종료되면 자동으로 삭제된다.(만료기간 설정 가능)

- 세션은 주로 보안이 중요한 로그인 정보를 유지하는데 사용한다.

- 동작방식

  1. 웹브라우저가 서버에 요청한다.

  2. 서버가 해당 웹브라우저에 유일한 ID(Session ID)를 부여한다.

  3. 서버가 응답할 때 HTTP 헤더에 Session ID를 포함해서 전송한다. 쿠키에 Session ID를 JSESSIONID라는 이름으로 저장한다.

     ```
     Set-Cookie: JSESSIONID=test
     ```

  4. 웹브라우저는 이후 웹브라우저를 닫기까지 다음 요청때 부여된 Session ID가 담겨있는 쿠키를 HTTP 헤더에 넣어서 전송한다.

     ```
     Cookie: JSESSIONID=test
     ```

  5. 서버는 세션ID를 확인하고, 해당 세션에 관련된 정보를 확인한 후 응답한다.



#### 쿠키 특징

- 클라이언트 로컬에 저장되는 키와 값이 들어있는 파일이다.

- 세션에 비해 보안적인 측면에서 좋지 않다.
- 서버에 저장되지 않고 브라우저에 저장되기에 서버 자원의 낭비를 방지할 수 있으며 빠르다.
- 브라우저가 종료되어도 쿠키에 설정한 만료 시간이 지나지 않으면 자동으로 삭제되지 않는다.
- 쿠키는 보안이 중요하지 않고 브라우저가 종료되어도 유지할 수 있는 정보에 사용된다.
- 주로 `팝업창 오늘 다시는 보지 않기`, 로그인시 `id 기억하기` , `쇼핑몰 장바구니` 등이 있다.

- 동작 방식

  1. 웹 브라우저가 서버에 요청한다.

  2. 상태를 유지하고 싶은 값을 쿠키로 생성한다.

  3. 서버가 응답할 때 HTTP 헤더에 쿠키를 포함해서 전송한다.

     ```
     Set-Cookie: id=test
     ```

  4. 전달받은 쿠키는 웹브라우저에서 관리하고 있다가 다음 요청할 때 쿠키를 HTTP 헤더에 넣어서 전송한다.

     ```
     cookie: id=doy
     ```

  5. 서버에서는 쿠키 정보를 읽어 이전 상태 정보를 확인한 후 응답한다.



### 세션 인증 방식과 토큰 인증 방식의 차이점

#### ※ 인증과 인가

**인증(Authentication)** : 유저가 누구인지 확인하는 절차, 회원가입하고 로그인하는 것이다.

**인가(Authorization)** : 유저에 대한 권한을 허락하는 것이다.



#### 세션 기반

##### 인증 방식

1. 유저가 로그인을 한다.
2. 로그인이 성공하면 서버는 메모리나 DB에 세션을 저장하고, 서버가 클라이언트에 세션 ID를 전송하여 쿠키에 저장한다.
3. 브라우저는 로그인이 되었는지 확인하기 위해 매 요청시 Request에 Session ID를 쿠키에 담아 전송한다.
4. 서버는 Session ID가 일치하는지 확인한 후 일치하면 요청에 응답한다.

##### 장점

- 서버 쪽에서 사용자의 로그인 상태에 확인이 쉽고 분명하다.
- 서버 쪽에서 세션 정보를 관리하기 때문에 클라이언트의 변조에 영향받기 어렵고 데이터의 손상 우려가 없어 상대적으로 안전하다.
- 토큰 방식에 Signature 등 부가적인 정보가 없기에 Server-Client간 주로 받는 데이터가 적다.

##### 단점

- 메모리에 저장된 세션정보는 휘발성이기에 서버 재부팅시 사라질 수 있으며 많은 정보를 저장하는데 한계가 있다.
- 쿠키는 단일 도메인, 서브 도메인에서만 작동하기 때문에 여러 도메인에서 사용할 경우 관리를 해줘야 한다.
- 세션 정보를 메모리에 저장하기엔 부담이 있다.



#### 토큰기반(JWT - JSON Web Token)

토큰기반 인증은 인증받은 사용자들에게 토큰을 발급하고, 서버에 요청을 할 때 헤더에 토큰을 함께 보내 유효성을 검사하는 방식이다.

##### 인증

1. 사용자가 로그인을 하면 서버측에서 계정 정보를 검증한다.
2. 검증이 완료되면, 서버측에서 클라이언트에게 signed token을 발급하고 클라이언트는 이를 저장한다.
3. 클라이언트는 서버에 요청시 저장된 토큰을 헤더에 포함시켜 보낸다.
4. 서버는 토큰 정보를 검증하고 해당 유저에 권한을 인가한다.

##### 장점

- 클라이언트가 토큰 정보를 갖고 있기 때문에 서버를 스케일업하는데 부담이 적다.
- 클라이언트 세션관리에 대한 서버의 메모리 부담을 줄일 수 있다.
- 다양한 도메인에 대응하는데 부담이 적다.

##### 단점

- 토큰에 signature 등의 부가적인 정보가 담겨 있기에 서버-클라이언트간 주고 받는 데이터가 세션 기반의 인증보다 많다.
- 토큰 인증을 위해 DB에서 매번 조회해야 하므로 DB 성능 부하가 있을 수 있다.



