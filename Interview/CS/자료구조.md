# 자료구조

## Array vs Linked List

### Array

Array는 논리적 저장 순서와 물리적 저장 순서가 일치한다. 그래서 인덱스로 해당 원소에 접근할 수 있고 찾고자 하는 원소의 인덱스를 알고 있으면 **O(1)**에 해당 원소로 접근할 수 있다. 즉, **random access**가 가능하다.

삭제나 추가를 할때는 빈공간을 채우기위해 원소들을 shift해줘야 하는 비용이 발생하여 Array 자료구조에서 시간복잡도의 worst case는 **O(n)**이 된다.



### Linked List

각각의 원소들은 자기 자신 다음에 어떤 원소인지만을 기억한다. 따라서 삭제와 삽입을 **O(1)**만에 해결할 수 있다.

하지만 원하는 위치를 찾는 과정에서 첫번째 원소부터 확인해야한다. 왜냐하면 Array와는 달리 논리적 저장순서와 물리적 저장순서가 일치하지 않기 때문이다. 이 과정 때문에 어떠한 원소를 삭제 또는 추가하고자 했을 때, 그 원소를 찾기 위해서 **O(n)**의 시간이 추가적으로 발생한다.

결국 Linked List는 검색에도 **O(n)**의 시간복잡도를 갖고 삽입, 삭제에도 **O(n)**의 시간복잡도를 갖는다. Linked List는 Tree 구조의 근간이 되며, 그 유용성이 드러난다.



## Stack and Queue

### Stack

선형 자료구조의 일정으로 **Last In First Out(LIFO)**. 나중에 들어간 원소가 먼저 나오는 것이 특징이다.



### Queue

선형 자료구조의 일종으로 **First In First Out(FIFO)**. 먼저 들어간 원소가 먼저 나온다. Stack과는 반대로 먼저 들어간 원소가 맨 앞에서 대기하다가 먼저 나오는 구조다.



## Tree

트리는 스택이나 큐와 같은 선형구조가 아닌 비선형 자료구조다. 트리는 계층적 관계를 표현하는 자료구조로 표현에 집중한다.

### 구성 용어

- Node (노드) : 트리를 구성하고 있는 각각의 요소를 의미한다.
- Edge(간선) : 트리를 구성하기 위해 노드와 노드를 연결하는 선을 의미한다.
- Root Node(루트 노드) : 트리 구조에서 최상위에 있는 노드를 의미한다.
- Terminal Node(= leaf Node, 단말 노드) : 하위에 다른 노드가 연결되어 있지 않은 노드를 의미한다.
- Internal Node(내부 노드, 비단말 노드) : 단말 노드를 제외한 모든 노드로 루트 노드를 포함한다.



### 이진트리(Binary Tree)

루트 노드를 중심으로 두개의 서브 트리로 나누어진다. 나누어진 두 서브 트리도 모두 이진 트리어야 한다. 공집합과 노드가 하나뿐인 것도 이진 트리 정의에 만족한다.

트리에서는 각 층별로 숫자를 매겨서 이를 트리의 레벨이라고 한다. 레벨의 값은 0부터 시작하고 루트 노드의 레벨은 0이다. 그리고 트리의 최고 레벨을 가리켜 해당 트리의 높이라고 한다.



### 포화 이진 트리(Perfect Binary Tree), 완전 이진 트리(Complete Binary Tree), 정 이진 트리(Full Binary Tree)

모든 레벨이 꽉 찬 이진 트리를 가리켜 **포화 이진 트리**라고 한다. 위에서 아래로, 왼쪽에서 오른쪽으로 순서대로 차곡차곡 채워진 이진 트리를 가리켜 **완전 이진 트리**라고 한다. 모든 노드가 0개 혹은 2개의 자식 노드만을 갖는 이진 트리를 가리켜 **정 이진 트리**라고 한다.

배열로 구성된 이진 트리는 노드의 개수가 n개이고, root가 0이 아닌 1에서 시작할 때, i번째 노드에 대해서 parent(i) = i/2, left_child(i) = 2i, right_child(i) = 2i+1의 index 값을 갖는다.



### BST(Binary Search Tree)

이진 탐색 트리는 이진 트리의 일종으로 데이터를 저장하는 규칙이 있다. 이 규칙은 특정 데이터의 위치를 찾는데 사용할 수 있다.

1. 이진 탐색 트리의 노드에 저자오딘 키는 유일하다.
2. 부모의 키가 왼쪽 자식 노드의 키보다 크다.
3. 부모의 키가 오른쪽 자식 노드의 키보다 작다.
4. 왼쪽과 오른쪽 서브트리도 이진 탐색 트리다.

이진 탐색 트리 탐색 연산의 시간복잡도는 **O(logn)**이다. 트리의 높이를 하나씩 더해갈수록 추가할 수 있는 노드의 수가 두배씩 증가하기 때문에 O(h)라 할 수 있다. 저장 순서에 따라 한쪽 노드만 추가되는 편향트리가 되면 성능에 영향을 미치며 시간복잡도는 **O(n)**이 된다.



## Binary Heap

자료구조의 일종으로 Tree 형식을 하고 있으며 Tree 중에서도 배열에 기반한 **완전 이진 트리(Complete Binary Tree)**이다. 배열에 트리의 값들을 넣어줄 때 0번째는 건너뛰고, 1번 인덱스부터 루트노드가 시작된다. 힙에는 최대힙, 최소힙 두종류가 있다.

최대 힙(Max Heap)이란, 각 노드의 값이 해당 children 값보다 크거나 같은 완전 이진 트리를 말한다.

최대 힙에서는 루트 노드에 있는 값이 제일 크므로, 최대 값을 찾는 연산의 시간 복잡도는 **O(1)**이다. 그리고 완전 이진 트리이기 때문에 배열을 사용하여 효율적으로 관리할 수 있다. (random access가 가능하다. Min Heap에서는 최소값을 찾는 연산의 시간복잡도가 **O(1)**)

하지만, 힙의 구조를 계속 유지하기 위해서는 제거된 루트 노드를 대체할 다른 노드가 필요하다. 여기서 heap은 맨 마지막 노드를 루트 노드로 대체시킨 후 다시 heapify 과정을 거쳐 heap 구조를 유지한다. 이런 경우에 O(logn)의 시간복잡도로 최댓값, 최솟값에 접근할 수 있다.



## Red Black Tree

**RBT**는 이진탐색트리를 기반으로 하는 트리 형식의 자료구조다. RBT는 탐색, 추가 삭제의 시간 복잡도가 **O(logn)**이 소요된다. 동일한 노드의 개수일 때, depth를 최소화하여 시간 복잡도를 줄이는 것이 핵심 아이디어다. 동일한 노드의 개수일 때, depth가 최소가 되는 경우는 tree가 완전 이진 트리인 경우다.

### 정의

1. 각 노드는 Red나 Black이라는 색을 갖는다.
2. Root node의 색깔은 Black이다.
3. 각 leaf node는 Black이다.
4. 어떤 노드의 색깔이 red라면 두 개의 children의 색은 모두 Black이다.



### 특징

1. 이진 탐색 트리이므로 BST의 특징을 모두 갖는다.
2. 루트 노드부터 단말 노드까지의 모든 경로 중 최소 경로로와 최대 경로의 크기 비율은 2보다 크지 않다. 이러한 상태를 `balanced` 상태라고 한다.



## Hash Table

`hash`는 내부적으로 배열을 사용하여 데이터를 저장하기 때문에 빠른 검색 속도를 갖는다. 특정한 값은 탐색하는데 데이터 고유의 인덱스로 접근하기 때문에 시간복잡도는 **O(1)**이 된다(평균 케이스). 문제는 인덱스로 저장되는 key 값이 불규칙한 것이다.

특별한 알고리즘을 이용하여 저장할 데이터와 연관된 고유한 숫자를 만들어 낸 뒤 이를 인덱스로 사용한다. 특정 데이터가 저장되는 인덱스는 그 데이터만의 고유한 위치이기 때문에, 삽입 연산시 다른 데이터의 사이에 끼어들거나, 삭제시 다른 데이터로 채울 필요가 없으므로 연산에 추가적 비용이 들지 않는다.



## Graph

정점과 간선의 집합, 트리 또한 그래프이며, 사이클이 허용되지 않는 그래프이다.



---

[참고1](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/DataStructure)

