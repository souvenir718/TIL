# Hositing

### 정의

 `hoist` 는 사전적 정의로 끌어올리기라는 뜻이다. 자바스크립트에서 끌어올려지는 것은 변수다. `var` 키워드로 선언된 모든 변수 선언은 **호이스트** 된다. **호이스트** 란 변수의 정의가 그 범위에 따라 **선언** 과 **할당** 으로 분리되는 것을 의미한다.

 즉, 변수가 함수 내에서 정의되었을 경우, 선언이 함수의 최상위로, 함수 바깥에서 정의되었을 경우, 전역 컨텍스트의 최상위로 변경이 된다.

 우선, **선언**과 **할당**을 이해해야 한다. 끌어올려지는 것은 **선언**이다.

```javascript
function getX() {
    console.log(x); // undefined
    var x = 100;
    console.log(x); // 100
}
getX();
```

 다른 언어의 경우, 변수 x를 선언하지 않고 출력하면 오류를 발생하지만 자바스크립트에서는 `undefined`로 출력된다. `var x = 100;` 이 구문에서 `var x;` 를 호이스트하기 때문이다. 작동 순서에 맞게 코드를 재구성하면 아래와 같다.



```javascript
function getX(){
    var x; // 선언
    console.log(x);
   	x = 100; // 할당
    console.log(x);
}
getX();
```

 **선언문**은 항상 **자바스크립트 엔진 구동시** 가장 최우선으로 해석하므로 호이스팅되고, **할당** 구문은 **런타임 과정**에서 이루어지 때문에 호이스팅되지 않는다.

 함수가 자신이 위치한 코드에 상관없이 함수 선언문 형태로 정의한 함수의 유효범위는 전체 코드의 맨 처음부터 시작한다. 함수 선언이 함수 실행 부분보다 뒤에 있더라도 **자바스크립트 엔진이 함수 선언을 끌어올리는 것**을 의미한다. 함수 호이스팅은 함수를 끌어올리지만 변수의 값은 끌어올리지 않는다



```javascript
foo();
function foo() {
    console.log('hello');
}
// hello
```

 foo 함수에 대한 선언을 호이스팅하여 global 객체에 등록시키기 때문에 `hello`가 출력된다.



```javascript
foo();
var foo = function() {
    console.log('hello');
}
// Uncaught TypeError : foo is not a function
```

 함수 리터럴을 할당하는 구조이기 때문에 호이스팅 되지 않으며 그렇기 때문에 런타임 환경에서 **Type Error** 를 발생시킨다.